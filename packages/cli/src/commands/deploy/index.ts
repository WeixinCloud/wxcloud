import { Command, flags } from '@oclif/command';
import rimraf from 'rimraf';
import { CloudAPI } from '@wxcloud/core';
import * as CloudKit from '@wxcloud/cloudkit';
import { CloudConfig } from '@wxcloud/core';
import { cli } from 'cli-ux';
import { existsSync, readFileSync } from 'node:fs';
import path from 'node:path';
import { uploadVersionPackage } from '../../api/files';
import { readLoginState } from '../../utils/auth';
import { chooseEnvId, chooseServiceId } from '../../utils/ux';
import { beginUpload } from '../storage/upload';
import chalk from 'chalk';
import { execWithLoading } from '../../utils/loading';
import { getDeployResult } from '../../functions/getDeployResult';
import ora from 'ora';

const { tcbDescribeCloudBaseBuildService, tcbDescribeWxCloudBaseRunEnvs, tcbSubmitServerRelease } =
  CloudAPI;

function extractCloudConfig(): CloudConfig {
  const cwd = process.cwd();
  const configFile = path.join(cwd, 'wxcloud.config.js');
  if (existsSync(configFile)) {
    // todo: if we got a config file, we can just run RunKit as-is.
    // since Dockerfile is expected to be generated by Dockerpacks.
    const config = require(configFile);
    return config;
  }
  // no config file, should prompt user to run `wxcloud migrate` first.
  throw new Error('没有配置文件，请先执行 `wxcloud migrate` 将项目迁移到云托管');
}
export default class DeployCommand extends Command {
  static description = '部署项目';

  static examples = [`wxcloud deploy`];

  static flags = {
    envId: flags.string({ char: 'e', description: '环境ID' }),
    serviceName: flags.string({ char: 's', description: '服务名' })
  };

  async run() {
    const { flags } = this.parse(DeployCommand);

    const envId = flags.envId || (await chooseEnvId());
    const serviceName = flags.serviceName || (await chooseServiceId(envId));
    const env = await tcbDescribeWxCloudBaseRunEnvs({});
    const target = env.envList.find(env => env.envId === envId);
    if (!target) {
      throw new Error(`环境 ${envId} 不存在`);
    }
    const cloudConfig = extractCloudConfig();
    let staticDomain: string | undefined;
    if (cloudConfig.type === 'universal') {
      if (target.staticStorages[0]?.staticDomain) {
        console.log(chalk.green.bold('静态资源'), target.staticStorages[0]?.staticDomain);
        staticDomain = `https://${target.staticStorages[0]?.staticDomain}`;
      } else {
        throw new Error('该环境尚未开通静态资源能力，请到控制台开通后再试');
      }
    }
    const res = await CloudKit.execAllKits({
      fullPath: process.cwd(),
      config: cloudConfig,
      staticDomain
    });
    console.log(chalk.yellow.bold('CloudKit'), res);
    if (res.runTarget) {
      const { uploadUrl, packageName, packageVersion } = await tcbDescribeCloudBaseBuildService({
        envId,
        serviceName: serviceName
      });
      await execWithLoading(() => uploadVersionPackage(uploadUrl, readFileSync(res.runTarget!)), {
        startTip: '云托管产物上传中...',
        successTip: '云托管产物上传成功'
      });
      if (!process.env.KEEP_DEPLOY_TARGET) {
        rimraf.sync(res.runTarget);
      }
      await tcbSubmitServerRelease({
        deployType: 'package',
        envId,
        hasDockerfile: true,
        releaseType: 'FULL',
        serverName: serviceName,
        dockerfile: 'Dockerfile',
        wxAppId: (await readLoginState()).appid,
        packageName,
        packageVersion,
        port: 3000,
        versionRemark: 'cloudkit'
      });
      console.log(chalk.green('云托管'), '版本创建成功');
    }
    if (res.staticTarget) {
      console.log(chalk.green('静态资源'), '准备上传中');
      for (const [local, remote] of Object.entries(res.staticTarget)) {
        await beginUpload(local, target.staticStorages[0], remote, 5);
      }
    }
    await getDeployResult({
      envId,
      isPrintLog: true,
      log: console.log,
      serviceName
    });
    // 部署完成，展示域名
    const domain = await CloudAPI.tcbDescribeCloudBaseRunServiceDomain({
      envId,
      serviceName
    });
    ora().succeed(`部署完成

服务 ${serviceName} 访问地址: 
> ${domain.defaultPublicDomain} `);
  }
}
